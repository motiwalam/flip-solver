UL = 0b100000000
U  = 0b010000000
UR = 0b001000000
L  = 0b000100000
S  = 0b000010000
R  = 0b000001000
BL = 0b000000100
B  = 0b000000010
BR = 0b000000001

UL = lambda n, i: i-n-1
U  = lambda n, i: i-n
UR = lambda n, i: i-n+1
L  = lambda n, i: i-1
S  = lambda n, i: i
R  = lambda n, i: i+1
BL = lambda n, i: i+n-1
B  = lambda n, i: i+n
BR = lambda n, i: i+n+1


def from_mask(n, i, m):
    nn = n*n
    o = vector(GF(2), nn)
    r = i//n
    c = i % n
    for j in m:
        k = j(n, i)
        if 0 <= k < nn and (abs(k//n - r) <= 1) and (abs(k%n - c) <= 1):
            o[k] = 1
    return o


def crosses_basis(n):
    """makes basis for when every cell affects its neighboring cross"""
    nn = n*n
    m = [U, L, S, R, B]
    return [
        Matrix(from_mask(n, i, m), nrows=n, ncols=n)
        for i in range(nn)
    ]


def masks_basis(n, ms):
    return [
        Matrix(from_mask(n, i, m), nrows=n, ncols=n)
        for i, m in enumerate(ms)
    ]


def url_to_gid(url):
    """
    Extracts the game ID from the link
    generated by Simon Tatham's website
    """
    return url[url.index('#')+1:]


def parse_gid(game_id):
    """
    parses the board and basis information
    from an instance of Flip, where the game_id
    is as specified by Simon Tatham's implementation
    """
    dims, desc = game_id.split(':')
    w,h = map(int, dims.split('x'))
    wh = w*h
    basis_bmp = [0] * (wh*wh)
    board_bmp = [0] * wh
    basis_desc, board_desc = desc.split(',')

    for bmp,desc in [(basis_bmp, basis_desc), (board_bmp, board_desc)]:
        for i, c in enumerate(desc):
            v = int(c, 16)
            for j in range(4):
                if i*4 + j < len(bmp):
                    if v & (8 >> j):
                        bmp[i*4+j] = 1
                    else:
                        bmp[i*4+j] = 0
    
    basis = [Matrix(GF(2), basis_bmp[wh*i:wh*(i+1)], nrows=h, ncols=w) for i in range(wh)]
    board = make_board(board_bmp, w, h)
    return board, basis
    

def make_board(l, w, h):
    """
    converts board written as a single list in row major order
    to a w x h Matrix over GF(2)
    """
    return Matrix(GF(2), l, nrows=h, ncols=w)


def solve_flip(target_board, basis):
    """
    solves an instance of Flip given
    the board as an n x m Matrix over GF(2)
    and a basis, which is a list with n * m elements 
    each of which is an n x m Matrix over GF(2)
    where the i'th element in the list indicates
    which cells in the grid are affected by clicking
    the i'th cell (when counted in row major order)
    """

    t = vector(target_board)
    nr = target_board.nrows()
    nc = target_board.ncols()
    A = Matrix(map(vector, basis)).T
    s = A.solve_right(t)
    return Matrix(s, nrows=nr, ncols=nc)


def solve_game_link(game_link):
    """
    solves an instance of Flip given the
    link generated by clicking "Link to this puzzle by game ID"
    on Simon Tatham's website
    """
    gid = url_to_gid(game_link)
    board, basis = parse_gid(gid)
    return solve_flip(board, basis)